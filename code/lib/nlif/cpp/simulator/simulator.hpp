/*
 *   This file is part of NEF Synaptic Computation
 *   (c) Andreas St√∂ckel 2017, 2018
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <array>
#include <cmath>
#include <cstddef>
#include <cstdint>
#include <iostream>
#include <fstream>
#include <random>

#include <Eigen/Dense>
#include <unsupported/Eigen/MatrixFunctions>

using namespace Eigen;

namespace {  // Do not export the following symbols
/**
 * Structure describing a single Poisson source. Note that Poisson sources are
 * automatically normalized such that the time-average is one. Use gain_min and
 * gain_max to adjust the average value of the input sequence.
 */
struct PoissonSource {
	/**
	 * Seed that should be used for the random number generator.
	 */
	uint32_t seed;

	/**
	 * Average rate of the PoissonSource. This corresponds to 1.0 / lambda.
	 */
	double rate;

	/**
	 * Uniform random gain minimum and maximum.
	 */
	double gain_min, gain_max;

	/**
	 * Time constant of the exponential synapse the PoissonSource is connected
	 * to.
	 */
	double tau;

	/**
	 * Constant offset that is applied to the input. When setting rate to zero,
	 * the offset corresponds to the value of a constant input.
	 */
	double offs;
};

/**
 * Structure describing an exponential filter that is applied to the input
 * signal.
 */
struct ExponentialFilter {
	/**
	 * Time constant of the exponential filter.
	 */
	double tau;

	/**
	 * Constant offset that is being added to the input.
	 */
	double offs;

	/**
	 * Multiplicative gain factor the input signal is scaled by.
	 */
	double gain;
};

/**
 * The SampledRandomDistribution function represents and arbitrary random
 * distribution by tabulating the inverse of the CDF.
 */
struct SampledRandomDistribution {
	/**
	 * No transformation should be applied to the random numbers generated from
	 * the random distribution.
	 */
	static constexpr int TRAFO_NONE = 0;

	/**
	 * The resulting number will be 10^x where x is the actually sampled value.
	 * This is used when sampling weights.
	 */
	static constexpr int TRAFO_EXP10 = 1;

	/**
	 * The resulting number will be 1 / (10^x), where x is the actually sampled
	 * value. This is used when sampling inter-spike intervals.
	 */
	static constexpr int TRAFO_EXP10_INV = 2;

	/**
	 * Seed that should be used for the random number generator.
	 */
	uint32_t seed;

	/**
	 * Number of samples in the table.
	 */
	uint32_t n;

	/**
	 * Table data. This function will linearly interpolate between table cells
	 * when looking up an entry.
	 */
	double *tbl;

	/**
	 * The transformaiton that shoudl be used on the resulting numbers. This can
	 * be one of the "TRAFO_" constants defined above.
	 */
	uint32_t trafo;

	/**
	 * Samples a value from the distribution assuming uniformly distributed x
	 * between 0.0 and 1.0.
	 */
	double sample(double x) const
	{
		// Compute the bin we should sample from assuming that the last bin
		// corresponds to exactly the value at x = 1.0
		const double bin = std::max(0.0, x * (n - 1));

		// Compute the bin indices and interpolation factors for linear
		// interpolation
		const uint32_t i0 = std::min<uint32_t>(n - 1, bin);
		const uint32_t i1 = std::min<uint32_t>(n - 1, bin + 1);
		const double f1 = bin - i0;
		const double f0 = 1.0 - f1;

		// Perform the actual linear interpolation
		const double y = tbl[i0] * f0 + tbl[i1] * f1;

		// Perform the desired ouptut transformation
		switch (trafo) {
			case TRAFO_EXP10:
				return std::pow(10.0, y);
			case TRAFO_EXP10_INV:
				return std::pow(10.0, -y);
			default:
				return y;
		}
	}
};

/**
 * The PoissonMatrixSource class is used to describe spike noise as created when
 * the PSC is generated by a bunch of weighted Poisson spike sources.
 */
struct PoissonMatrixSource {
	/**
	 * Random number generator seed.
	 */
	uint32_t seed;

	/**
	 * Time constant of the exponential filter.
	 */
	double tau;

	/**
	 * Constant offset that is being added to the input.
	 */
	double offs;

	/**
	 * Multiplicative gain factor the input signal is scaled by.
	 */
	double gain;

	/**
	 * Number of pre-synaptic neurons.
	 */
	uint32_t n;

	/**
	 * Pre-synaptic neuron spike rates.
	 */
	double *rates;

	/**
	 * Pre-synaptic neuron weights.
	 */
	double *weights;
};

template <typename Parameters>
class Simulator {
private:
	/*
	 * Somatic constants
	 */
	static constexpr double Cm = Parameters::Cm;
	static constexpr double tau_ref = Parameters::tau_ref;
	static constexpr double tau_spike = Parameters::tau_spike;
	static constexpr double v_th = Parameters::v_th;
	static constexpr double v_reset = Parameters::v_reset;
	static constexpr double v_spike = Parameters::v_spike;

	/*
	 * Constants describing the neuron model
	 */
	static constexpr size_t n_comp = Parameters::n_comp;
	static constexpr size_t n_inputs = Parameters::n_inputs;

	/*
	 * Simulator-specific constants
	 */
	static constexpr size_t ss = Parameters::ss;
	static constexpr double dt = Parameters::dt;
	static constexpr double dt_inv = 1.0 / (dt * ss);
	static constexpr double spike_time_resolution =
	    Parameters::spike_time_resolution;

	/*
	 * Type aliases
	 */
	using MatA = typename Parameters::MatA;
	using VecASom = typename Parameters::VecASom;
	using VecB = typename Parameters::VecB;
	using VecX = typename Parameters::VecX;
	using VecV = typename Parameters::VecV;

	/**
	 * Recording flags
	 */
	static constexpr bool record_out = Parameters::record_out;
	static constexpr bool record_isom = Parameters::record_isom;
	static constexpr bool record_voltages = Parameters::record_voltages;
	static constexpr bool record_spike_times = Parameters::record_spike_times;
	static constexpr bool record_in_refrac = Parameters::record_in_refrac;

	/**
	 * Returns the A matrix of the linear dynamical system.
	 *
	 * @param x is the vector containing the input data.
	 * @param tar is the target matrix.
	 */
	static MatA calc_A(const VecX &x) { return Parameters::calc_A(x); }

	/**
	 * Returns the b vector of the linear dynamical system.
	 *
	 * @param x is the vector containing the input data.
	 * @param tar is the target matrix.
	 */
	static VecB calc_b(const VecX &x) { return Parameters::calc_b(x); }

	/**
	 * Calculates the first row of the A-matrix as required for the calculation
	 * of the somatic current.
	 */
	static VecASom calc_Asom(const VecX &x) { return Parameters::calc_Asom(x); }

	/**
	 * Calculates the first entry of the b-vector as required for the
	 * calculation of the somatic current.
	 */
	static double calc_bsom(const VecX &x) { return Parameters::calc_bsom(x); }

public:
	/**
	 * Executes the actual neuron simulation.
	 *
	 * @param state is a pointer at an array of doubles holding the neuron
	 * state. This array must have m + 1 elements, where m is the number of
	 * compartments in the neuron model.
	 * @param xs is a functor that either returns a VecX or a pointer at a
	 * memory region containing n_inputs doubles.
	 * @param spike_count is a variable to which the total number of spikes
	 * during the simulation period will be written.
	 * @param n is the number of samples.
	 * @param res_out is the target array that determines whether a neuron
	 * spiked (entry set to true) or did not spike (entry set to false).
	 * @param res_isom stores the somatic current recorded from the neuron.
	 * @param res_v stores the recorded voltages for the neuron simulation. The
	 * target matrix must have size n x m, where n is the number of samples and
	 * m is the number of compartments.
	 * @param res_times is an array holding the spike times. Must be of size n.
	 * The actual number of spike times is written to the spike_count variable.
	 */
	template <typename F>
	static void run_from_functor(double *state, F f, uint32_t n,
	                             uint32_t *spike_count, double *res_out,
	                             double *res_isom, double *res_v,
	                             double *res_times, bool *res_in_refrac)
	{
		// Map the state vector to the membrane potentials and the refractory
		// period
		Map<VecV> v(state);
		double &tref = state[n_comp];

		for (size_t i = 0; i < n; i++) {
			for (size_t s = 0; s < ss; s++) {
				// Fetch the input data
				const VecX x = f(i, s);

				// Compute the A-matrix and the b-vector for this sample
				MatA A = calc_A(x);
				VecB b = calc_b(x);

				// Compute the equilibrium potential
				const VecV vEq = (-A).ldlt().solve(b);

				// Compute the membrane potential of all compartments
				v = vEq + ((A * dt).exp() * (v - vEq));

				// Handle the refractory/spike period for the somatic
				// compartment
				if (tref >= dt) {
					tref -= dt;
					if (tref > tau_ref) {
						v[0] = v_spike;
					}
					else {
						v[0] = v_reset;
					}
					if (s == 0 && record_in_refrac) {
						res_in_refrac[i] = true;
					}
				}

				// Record somatic currents if requested
				if (s == 0 && record_isom) {
					const VecASom Asom = calc_Asom(x);
					const double bsom = calc_bsom(x);
					res_isom[i] = Cm * (Asom * v + bsom);
				}

				// Handle spike production, compute accurate spike times
				if (v[0] > v_th && tref < dt) {
					// Record the accurate spike time
					if (record_spike_times) {
						res_times[*spike_count] = (i * ss + s) * dt;
					}

					// The neuron spiked, account for the amount of time the
					// neuron already spent in the refractory state since the
					// beginning of the timestep
					tref = tau_ref + tau_spike - dt;
					v[0] = (tau_spike > 0.0) ? v_spike : v_reset;

					// Record the spike
					if (record_out) {
						res_out[i] += dt_inv;
					}

					// Increment the spike counter
					(*spike_count)++;
				}

				// Record voltages if requested
				if (s == 0 && record_voltages) {
					double *res_v_vec = res_v + i * n_comp;
					for (size_t j = 0; j < n_comp; j++) {
						res_v_vec[j] = v[j];
					}
				}
			}
		}
	}

	/**
	 * Same as run_from_functor() but uses input data stored in memory. See
	 * run_from_functor() for arguments.
	 *
	 * @param xs contains the input data that is being fed to the individual
	 * compartments. This matrix is row-major, i.e. input for the individual
	 * compartments is stored continously and repeated for each sample (i.e. one
	 * row is one sample and each row contains the individual compartment
	 * inputs, which are stored continously in memory).
	 */
	static void run_from_memory(double *state, const double *xs, uint32_t n,
	                            uint32_t *spike_count, double *res_out,
	                            double *res_isom, double *res_v,
	                            double *res_times, bool *res_in_refrac)
	{
		// Function which reads the current input sample from memory
		auto f = [xs](size_t i, size_t) {
			return Map<const VecX>(xs + n_inputs * i);
		};

		// Run the simulation with the above input functor
		run_from_functor(state, f, n, spike_count, res_out, res_isom, res_v,
		                 res_times, res_in_refrac);
	}

	/**
	 * Uses run_from_functor with a set of Poisson distributed spike sources as
	 * inputs.
	 *
	 * @param sources is a list of PoissonSource descriptors.
	 */
	static void run_with_poisson_sources(double *state,
	                                     const PoissonSource *sources,
	                                     uint32_t n, uint32_t *spike_count,
	                                     double *res_out, double *res_isom,
	                                     double *res_v, double *res_times,
	                                     bool *res_in_refrac)
	{
		// Initialize the individual random engines for the input channels,
		// pre-compute some filter constants
		std::array<std::mt19937, n_inputs> random_engines;
		std::array<std::exponential_distribution<double>, n_inputs> dist_exp;
		std::array<std::uniform_real_distribution<double>, n_inputs> dist_gain;
		VecX filt, xs, offs, T;
		for (size_t j = 0; j < n_inputs; j++) {
			// Initialize the random engine for this input with the seed
			// specified by the user
			random_engines[j].seed(sources[j].seed);

			// Compute the filter coefficient
			filt[j] = 1.0 - dt / sources[j].tau;

			// Setup the poisson distribution and draw the first spike time
			dist_exp[j] =
			    std::exponential_distribution<double>(sources[j].rate);
			T[j] = dist_exp[j](random_engines[j]);

			// Setup the uniform gain distribution and initialize xs to the
			// average value
			const double scale = 1.0 / (sources[j].tau * sources[j].rate);
			dist_gain[j] = std::uniform_real_distribution<double>(
			    sources[j].gain_min * scale, sources[j].gain_max * scale);
			xs[j] = 0.5 * (sources[j].gain_min + sources[j].gain_max);

			// Copy the offset
			offs[j] = sources[j].offs;
		}

		// Implement the Poisson Source
		auto f = [&](size_t i, size_t s) {
			// Generate new input events
			const double curT = (i * ss + s) * dt;
			for (size_t j = 0; j < n_inputs; j++) {
				while (T[j] < curT) {
					// Feed a Delta pulse into the input
					xs[j] += dist_gain[j](random_engines[j]);

					// Compute the next spike time
					T[j] += dist_exp[j](random_engines[j]);
				}
			}

			// Apply the exponential filter
			xs = xs.array() * filt.array();

			// Return the result
			return xs + offs;
		};

		// Run the actual simulation
		run_from_functor(state, f, n, spike_count, res_out, res_isom, res_v,
		                 res_times, res_in_refrac);
	}

	/**
	 * Uses run_from_functor with a set of Poisson distributed spike sources as
	 * inputs.
	 *
	 * @param sources is a list of PoissonSource descriptors.
	 */
	static void run_with_noise_profile(
	    double *state, const ExponentialFilter *filters,
	    const SampledRandomDistribution *p_weights,
	    const SampledRandomDistribution *p_isi, uint32_t n,
	    uint32_t *spike_count, double *res_out, double *res_isom, double *res_v,
	    double *res_times, bool *res_in_refrac)
	{
		// Initialize the individual random engines for the input channels,
		// pre-compute some filter constants
		std::array<std::mt19937, n_inputs> random_engines_weights;
		std::array<std::mt19937, n_inputs> random_engines_isi;
		std::uniform_real_distribution<double> dist_uniform(0.0, 1.0);
		VecX gains, filt, xs, offs, T, mean;
		for (size_t j = 0; j < n_inputs; j++) {
			// Initialize the random engines
			random_engines_weights[j].seed(p_weights[j].seed);
			random_engines_isi[j].seed(3821 + 4822 * p_isi[j].seed);

			// Pre-compute some filter constants
			const double dt_eff = dt / filters[j].tau;
			filt[j] = 1.0 - dt_eff;
			offs[j] = filters[j].offs;
			gains[j] = dt_eff * filters[j].gain * (1.0 - 0.5 * dt_eff);
			T[j] = 0.0;

			mean[j] = 0.0;
		}

		// Implement the generic random spike source
		auto f = [&](size_t i, size_t s) {
			// Generate new input events
			const double curT = (i * ss + s) * dt;
			for (size_t j = 0; j < n_inputs; j++) {
				while (T[j] < curT) {
					// Feed a Delta pulse into the input
					const double x_weight =
					    dist_uniform(random_engines_weights[j]);
					xs[j] += p_weights[j].sample(x_weight) * gains[j];

					// Compute the next spike time
					const double x_isi = dist_uniform(random_engines_isi[j]);
					T[j] += p_isi[j].sample(x_isi);
				}
			}

			// Apply the exponential filter
			xs = xs.array() * filt.array();

			if (s == 0) {
				mean += xs;
			}

			// Return the result
			return xs + offs;
		};

		// Run the actual simulation
		run_from_functor(state, f, n, spike_count, res_out, res_isom, res_v,
		                 res_times, res_in_refrac);
	}

	/**
	 * Uses run_from_functor with an exponentially filtered input.
	 */
	static void run_with_exponential_filter(double *state, const double *xs,
	                                        const ExponentialFilter *filters,
	                                        uint32_t n, uint32_t *spike_count,
	                                        double *res_out, double *res_isom,
	                                        double *res_v, double *res_times,
	                                        bool *res_in_refrac)
	{
		// Pre-compute some filter constants
		VecX filt, x, offs, gains, T;
		for (size_t j = 0; j < n_inputs; j++) {
			const double dt_eff = dt / filters[j].tau;
			filt[j] = 1.0 - dt_eff;
			x[j] = 0.0;
			offs[j] = filters[j].offs;
			gains[j] = dt_eff * filters[j].gain * (1.0 - 0.5 * dt_eff);
		}

		// Implement the low-pass filter
		auto f = [&](size_t i, size_t) {
			// Fetch the current input
			const VecX in = Map<const VecX>(xs + n_inputs * i);

			// Add the input to the current signal and apply the filter
			x = in.array() * gains.array() + x.array() * filt.array();

			// Return the result
			return x + offs;
		};

		// Run the actual simulation
		run_from_functor(state, f, n, spike_count, res_out, res_isom, res_v,
		                 res_times, res_in_refrac);
	}

	static void run_with_matrix_poisson_source(
	    double *state, const PoissonMatrixSource *sources, uint32_t n,
	    uint32_t *spike_count, double *res_out, double *res_isom, double *res_v,
	    double *res_times, bool *res_in_refrac)
	{
//		std::ofstream tf("trace.csv");

		// Pre-compute some filter constants
		std::array<std::mt19937, n_inputs> random_engines;
		std::array<VectorXd, n_inputs> ps;
		std::uniform_real_distribution<double> dist_uniform(0.0, 1.0);
		std::array<std::exponential_distribution<double>, n_inputs> dist_exp;
		VecX filt, x, offs, gains, T;
		for (size_t j = 0; j < n_inputs; j++) {
			// Initialize the random engine for this input with the seed
			// specified by the user
			random_engines[j].seed(sources[j].seed);

			// Compute the filter parameters
			const double dt_eff = dt / sources[j].tau;
			T[j] = 0.0;
			filt[j] = 1.0 - dt_eff;
			x[j] = 0.0;
			offs[j] = sources[j].offs;
			gains[j] = dt_eff * sources[j].gain * (1.0 - 0.5 * dt_eff) / dt;

			// Initialize the vector containing the source selection
			// probabilities
			ps[j].resize(sources[j].n);
			double total_rate = 0.0;
			//double target = 0.0;
			for (size_t k = 0; k < sources[j].n; k++) {
				total_rate += sources[j].rates[k];
			}
			for (size_t k = 0; k < sources[j].n; k++) {
				ps[j][k] = sources[j].rates[k] / total_rate;
				if (k > 0) {
					ps[j][k] += ps[j][k - 1];
				}
//				tf << '#' << j << "\t" << k << "\t" << ps[j][k] << "\t" << sources[j].rates[k] << "\t" << sources[j].weights[k] << "\t" << sources[j].gain << std::endl;
			}

			// Initialize the exponential distribution
			dist_exp[j] = std::exponential_distribution<double>(total_rate);
//			tf << "# total rate: " << total_rate << std::endl;
		}

		// Implement the Poisson Source
		auto f = [&](size_t i, size_t s) mutable {
			// Generate new input events
			const double curT = (i * ss + s) * dt;
			for (size_t j = 0; j < n_inputs; j++) {
				while (T[j] < curT) {
					// Select a spike weight and feed a Delta pulse into the
					// input
					const size_t n = sources[j].n;
					const double p = dist_uniform(random_engines[j]);
					const auto &psj = ps[j];
					size_t k;
					if (n > 0) {
						for (k = 0; k < n && p > psj[k]; k++);
						x[j] += sources[j].weights[k] * gains[j];
					}

					// Compute the next spike time
					T[j] += dist_exp[j](random_engines[j]);
				}
			}

			// Apply the exponential filter
			x = x.array() * filt.array();

//			tf << curT << "\t" << x[0] << "\t" << x[1] << std::endl;

			// Return the result
			return x + offs;
		};

		// Run the actual simulation
		run_from_functor(state, f, n, spike_count, res_out, res_isom, res_v,
		                 res_times, res_in_refrac);
	}
};
}  // namespace
