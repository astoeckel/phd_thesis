#!/usr/bin/env python3

#  libnlif -- Multi-compartment LIF simulator and weight solver
#  Copyright (C) 2017-2021  Andreas St√∂ckel
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <https://www.gnu.org/licenses/>.

import io, os
import numpy as np

from ctypes import (cdll, POINTER, Structure, cast, c_double, c_size_t,
                    c_uint32, c_uint8, c_void_p)
c_double_p = POINTER(c_double)
c_uint32_p = POINTER(c_uint32)
c_uint8_p = POINTER(c_uint8)

from .simulator_types import (TRAFO_NONE, TRAFO_EXP10, TRAFO_EXP10_INV, Result,
                              PoissonSource, ExponentialFilter,
                              SampledRandomDistribution, PoissonMatrixSource)
from .cmodule import compile_cpp_library, SharedLibrary


def _generate_simulator_cpp_code(f,
                                 soma,
                                 sys,
                                 dt=1e-4,
                                 ss=1,
                                 record_out=True,
                                 record_isom=False,
                                 record_voltages=False,
                                 record_spike_times=False,
                                 record_in_refrac=False):
    def _fmt(x):
        res = "{:g}".format(x)
        if (not "." in res):
            s = res.split('e')
            s[0] += '.0'  # Ensure number is C++ double, just '.' would work, but is ugly
            return 'e'.join(s)
        return res

    # Code below compares the result of _fmt to the string "0.0"
    assert _fmt(0) == "0.0" and _fmt(0.0) == "0.0"

    def _fmt_bool(b):
        return "true" if b else "false"

    def _generate_b_vec_entry(i, B, Bconst):
        res = _fmt(Bconst[i])
        if res == "0.0":
            res = ""
        for k in range(B.shape[1]):
            if B[i, k] != 0.0:
                if len(res) > 0:
                    res += " + "
                res += "({} * x[{}])".format(_fmt(B[i, k]), k)
        if res == "":
            return "0.0"
        return res

    def _generate_A_mat_entry(i, j, A, Aconst, L):
        res = "- (" + _fmt(L[i, j])
        if i == j:
            res += " + " + _generate_b_vec_entry(i, A, Aconst)
        return res + ")"

    def _generate_compute_b_code(f, B, Bconst):
        """
        Function used internally to generate the code that computes the B-matrix of
        the linear dynamical system given a certain input vector.
        """
        # Iterate over the rows in b and write the code which computes the
        # corresponding value
        for i in range(B.shape[0]):
            f.write("        gsl_vector_set(tar, {}, ".format(i))
            f.write(_generate_b_vec_entry(i, B, Bconst))
            f.write(");\n")

    # Fetch some constants
    n_inputs = sys.n_inputs
    n_comp = sys.n_compartments
    """
    Generates the C++ code representing a specific neuron simulator and stores
    it in the given file descriptor.

    Parameters
    ==========

    See `AssembledNeuron.make_simulator()` for a complete list of parameters.

    f: file to which the C++ code should be written.
    sys: AssembledNeuron instance.
    """

    f.write(
        """// This code was automatically generated by multi_compartment_lif_cpp.py

#include "simulator.hpp"
#include "visibility.h"

namespace { // Do not export the following symbols
struct Parameters {
    static constexpr double Cm = """ + _fmt(soma.C_m) + """;
    static constexpr double tau_ref = """ + _fmt(soma.tau_ref) + """;
    static constexpr double tau_spike = """ + _fmt(soma.tau_spike) + """;
    static constexpr double v_th = """ + _fmt(soma.v_th) + """;
    static constexpr double v_reset = """ + _fmt(soma.v_reset) + """;
    static constexpr double v_spike = """ + _fmt(soma.v_spike) + """;
    static constexpr size_t n_comp = """ + str(n_comp) + """;
    static constexpr size_t n_inputs = """ + str(n_inputs) + """;
    static constexpr double dt = """ + _fmt(dt) + """;
    static constexpr size_t ss = """ + str(ss) + """;

    static constexpr bool record_out = """ + _fmt_bool(record_out) + """;
    static constexpr bool record_isom = """ + _fmt_bool(record_isom) + """;
    static constexpr bool record_voltages = """ + _fmt_bool(record_voltages) +
        """;
    static constexpr bool record_spike_times = """ +
        _fmt_bool(record_spike_times) + """;
    static constexpr bool record_in_refrac = """ +
        _fmt_bool(record_in_refrac) + """;

    using MatA = Matrix<double, n_comp, n_comp>;
    using VecASom = Matrix<double, 1, n_comp>;
    using VecB = Matrix<double, n_comp, 1>;
    using VecX = Matrix<double, n_inputs, 1>;
    using VecV = Matrix<double, n_comp, 1>;

    static MatA calc_A(const VecX &x) {
        (void)x; // x may be unused, suppress warnings
        return (MatA() <<\n""")
    for i in range(n_comp):
        for j in range(n_comp):
            f.write("            {}".format(
                _generate_A_mat_entry(i, j, sys.A, sys.a_const, sys.L)))
            if i != n_comp - 1 or j != n_comp - 1:
                f.write(",")
            f.write("\n")
    f.write("""        ).finished();
    }

    static VecB calc_b(const VecX &x) {
        (void)x; // x may be unused, suppress warnings
        return (VecB() <<\n""")
    for i in range(n_comp):
        f.write("            {}".format(
            _generate_b_vec_entry(i, sys.B, sys.b_const)))
        if i != n_comp - 1:
            f.write(",")
        f.write("\n")
    f.write("""        ).finished();
    }

    static VecASom calc_Asom(const VecX &x) {
        (void)x; // x may be unused, suppress warnings
        return (VecASom() <<\n""")
    for i in range(n_comp):
        f.write("            {}".format(
            _generate_A_mat_entry(0, i, sys.A, sys.a_const - sys.a_const_intr,
                                  sys.L)))
        if i != n_comp - 1:
            f.write(",")
        f.write("\n")
    f.write("""        ).finished();
    }

    static double calc_bsom(const VecX &x) {
        (void)x; // x may be unused, suppress warnings
        return """ +
            _generate_b_vec_entry(0, sys.B, sys.b_const - sys.b_const_intr) +
            """;
    }
};
}

extern "C" { // Exported C API
DLL_PUBLIC void simulate(
    double *state,
    const double *xs, uint32_t n, uint32_t *spike_count,
    double *res_out, double *res_isom, double *res_v, double *res_times,
    bool *res_in_refrac) {
    Simulator<Parameters>::run_from_memory(
        state, xs, n, spike_count,
        res_out, res_isom, res_v, res_times, res_in_refrac);
}

DLL_PUBLIC void simulate_poisson(
    double *state,
    const PoissonSource *sources, uint32_t n, uint32_t *spike_count,
    double *res_out, double *res_isom, double *res_v, double *res_times,
    bool *res_in_refrac) {
    Simulator<Parameters>::run_with_poisson_sources(
        state, sources, n, spike_count,
        res_out, res_isom, res_v, res_times, res_in_refrac);
}

DLL_PUBLIC void simulate_filtered(
    double *state,
    const double *xs, uint32_t n, uint32_t *spike_count,
    double *res_out, double *res_isom, double *res_v, double *res_times,
    bool *res_in_refrac, ExponentialFilter *filters) {
    Simulator<Parameters>::run_with_exponential_filter(
        state, xs, filters, n, spike_count,
        res_out, res_isom, res_v, res_times, res_in_refrac);
}

DLL_PUBLIC void simulate_noise_profile(
    double *state, const ExponentialFilter *filters, uint32_t n,
    uint32_t *spike_count, double *res_out, double *res_isom, double *res_v,
    double *res_times, bool *res_in_refrac, 
    const SampledRandomDistribution *p_weights,
    const SampledRandomDistribution *p_isi) {
    Simulator<Parameters>::run_with_noise_profile(
        state, filters, p_weights, p_isi, n, spike_count, res_out, res_isom,
        res_v, res_times, res_in_refrac
    );
}

DLL_PUBLIC void simulate_poisson_matrix_source(
    double *state, const PoissonMatrixSource *sources, uint32_t n,
    uint32_t *spike_count, double *res_out, double *res_isom, double *res_v,
    double *res_times, bool *res_in_refrac) {
    Simulator<Parameters>::run_with_matrix_poisson_source(
        state, sources, n, spike_count, res_out, res_isom,
        res_v, res_times, res_in_refrac
    );
}
};
""")


def _cpp_dir(*f):
    return os.path.join(os.path.realpath(os.path.dirname(__file__)), '..',
                        'cpp', *f)


def _compile_simulator_cpp(
    soma,
    sys,
    dt=1e-4,
    ss=1,
    record_out=True,
    record_isom=False,
    record_voltages=False,
    record_spike_times=False,
    record_in_refrac=False,
    debug=False,
    parallel_compile=True,
):
    # Generate the C++ code
    f = io.StringIO()
    _generate_simulator_cpp_code(f, soma, sys, dt, ss, record_out, record_isom,
                                 record_voltages, record_spike_times,
                                 record_in_refrac)

    # Compute the location of the header file
    inc_simulator = _cpp_dir('simulator')
    inc_eigen = _cpp_dir('extern', 'eigen')
    inc_cpp = _cpp_dir()
    code = f.getvalue().encode('utf-8')

    # Compile the C++ code into a library. This automatically takes care of not
    # compiling the same code multiple times
    lib_file = compile_cpp_library(
        code,
        include_dirs=[inc_simulator, inc_eigen, inc_cpp],
        debug=debug,
        parallel=parallel_compile)

    return SharedLibrary(lib_file)


class SimulatorCpp:
    def __init__(self,
                 assembled_neuron,
                 dt=1e-4,
                 ss=1,
                 record_out=True,
                 record_isom=False,
                 record_voltages=False,
                 record_spike_times=False,
                 record_in_refrac=False,
                 debug=False,
                 parallel_compile=False):
        # Copy the given system and other arguments
        self.assembled_neuron = assembled_neuron
        self.soma = assembled_neuron.soma
        self.dt = float(dt)
        self.ss = int(ss)
        self.record_out = bool(record_out)
        self.record_isom = bool(record_isom)
        self.record_voltages = bool(record_voltages)
        self.record_spike_times = bool(record_spike_times)
        self.record_in_refrac = bool(record_in_refrac)

        self.lib = lib = _compile_simulator_cpp(
            soma=self.assembled_neuron.compartments[0],
            sys=self.assembled_neuron.system,
            dt=self.dt,
            ss=self.ss,
            record_out=self.record_out,
            record_isom=self.record_isom,
            record_voltages=self.record_voltages,
            record_spike_times=self.record_spike_times,
            record_in_refrac=self.record_in_refrac,
            debug=debug,
            parallel_compile=parallel_compile)
        self.c_simulate = lib.simulate
        self.c_simulate_poisson = lib.simulate_poisson
        self.c_simulate_filtered = lib.simulate_filtered
        self.c_simulate_noise_profile = lib.simulate_noise_profile
        self.c_simulate_poisson_matrix_source = lib.simulate_poisson_matrix_source

    def _mk_state(self, state):
        n_comp = self.n_compartments
        if state is None:
            state = np.zeros(n_comp + 1, dtype=np.float64)
            state[:n_comp] = self.assembled_neuron.v_eq()
            state[-1] = 0.0  # Remaining refractory period
        else:
            assert state.size == n_comp + 1
        return state.astype(np.float64, order='C', copy=False)

    def _do_simulate(self, state, n_samples, c_fun, c_xs_p, extra_args=[]):
        n_comp = self.n_compartments

        # Generate the input state
        stated = self._mk_state(state)

        # An upper bound on the number of spikes the neuron can produce
        tau_ref = self.soma.tau_ref
        if tau_ref > 0.0:
            max_n_spikes = np.ceil(1.0 / self.soma.tau_ref) * np.ceil(
                n_samples * self.dt * self.ss) + 1
        else:
            max_n_spikes = n_samples

        # Generate the output arrays
        res_out = np.zeros(n_samples, np.float64) if self.record_out else None
        res_isom = np.empty(n_samples, np.float64) if self.record_isom else None
        res_v = np.empty(
            (n_samples, n_comp), np.float64) if self.record_voltages else None
        res_times = np.empty(int(max_n_spikes),
                             np.float64) if self.record_spike_times else None
        res_in_refrac = np.zeros(n_samples,
                                 np.bool) if self.record_in_refrac else None

        # Memory storing the number of output spikes
        n_spikes = np.zeros(1, np.uint32)

        # Run the simulation
        c_fun(
            stated.ctypes.data_as(c_double_p), c_xs_p, c_uint32(n_samples),
            n_spikes.ctypes.data_as(c_uint32_p),
            res_out.ctypes.data_as(c_double_p)
            if self.record_out else c_void_p(0),
            res_isom.ctypes.data_as(c_double_p)
            if self.record_isom else c_void_p(0),
            res_v.ctypes.data_as(c_double_p)
            if self.record_voltages else c_void_p(0),
            res_times.ctypes.data_as(c_double_p)
            if self.record_spike_times else c_void_p(0),
            res_in_refrac.ctypes.data_as(c_uint8_p)
            if self.record_in_refrac else c_void_p(0), *extra_args)

        # Convert the spike times array to a list
        if self.record_spike_times:
            res_times = res_times[:n_spikes[0]]

        return Result(self.dt, self.ss, n_samples, stated, res_out, res_isom,
                      res_v, res_times, res_in_refrac)

    def simulate_poisson(self, sources, n_samples, state=None):
        """
        Runs the Simulation for a set of poisson sources as input.
        """
        # Generate the input state
        state = self._mk_state(state)

        # Make sure the number of input samples is valid
        n_samples = int(n_samples)
        assert (n_samples >= 0)

        # Make sure the sources array is valid and copy the data over to a
        # C array
        assert (len(sources) == self.n_inputs)
        c_sources = (PoissonSource * self.n_inputs)()
        for i in range(self.n_inputs):
            c_sources[i].seed = sources[i].seed
            c_sources[i].rate = sources[i].rate
            c_sources[i].gain_min = sources[i].gain_min
            c_sources[i].gain_max = sources[i].gain_max
            c_sources[i].tau = sources[i].tau
            c_sources[i].offs = sources[i].offs

        c_poisson_source_p = POINTER(PoissonSource)

        return self._do_simulate(state, n_samples, self.c_simulate_poisson,
                                 cast(c_sources, c_poisson_source_p))

    def simulate_noise_profile(self,
                               qs_weights,
                               qs_isi,
                               filters,
                               n_samples,
                               state=None):
        """
        Runs the simulation where the input spikes and weightings are
        sampled from two pre-defined random distribution.
        """

        # Make sure the number of noise distributions/filters corresponds
        # to the number of input channels
        assert (len(qs_weights) == len(qs_isi) == len(filters) == self.n_inputs)

        c_qs_weights = (SampledRandomDistribution * self.n_inputs)()
        c_qs_isi = (SampledRandomDistribution * self.n_inputs)()
        c_filters = (ExponentialFilter * self.n_inputs)()
        for i in range(self.n_inputs):
            assert (isinstance(qs_weights[i], SampledRandomDistribution))
            assert (isinstance(qs_isi[i], SampledRandomDistribution))

            SampledRandomDistribution.populate(c_qs_weights[i], qs_weights[i])
            SampledRandomDistribution.populate(c_qs_isi[i], qs_isi[i])
            ExponentialFilter.populate(c_filters[i], filters[i])

        c_exponential_filter_p = POINTER(ExponentialFilter)
        c_sampled_random_distribution_p = POINTER(SampledRandomDistribution)

        return self._do_simulate(
            state, n_samples, self.c_simulate_noise_profile,
            cast(c_filters, c_exponential_filter_p), [
                cast(c_qs_weights, c_sampled_random_distribution_p),
                cast(c_qs_isi, c_sampled_random_distribution_p),
            ])

    def simulate(self, xs, state=None):
        """
        Runs the Simulation with the given input xs. xs is a 2D matrix
        containing the input for each point in time.
        """

        # Make sure the given xs vector has the correct shape
        xs, _ = self.assembled_neuron._canonicalise_input_array(xs)

        # Fetch some values used throughout the function
        n_samples = xs.shape[0]

        # Make sure the input array is an array of doubles
        xsd = xs.astype(np.float64, order='C', copy=False)

        return self._do_simulate(state, n_samples, self.c_simulate,
                                 xsd.ctypes.data_as(c_double_p))

    def simulate_filtered(self, xs, filters, state=None):
        """
        Runs the Simulation with the given input xs filtered with the
        exponential low-pass filters defined 
        """

        # Generate the input state
        stated = self._mk_state(state)

        # Make sure the given xs vector has the correct shape
        xs, _ = self.assembled_neuron._canonicalise_input_array(xs)

        # Make sure the number of input samples is valid
        n_samples = xs.shape[0]

        # Make sure the sources array is valid and copy the data over to a
        # C array
        assert (len(filters) == self.n_inputs)
        c_filters = (ExponentialFilter * self.n_inputs)()
        for i in range(self.n_inputs):
            ExponentialFilter.populate(c_filters[i], filters[i])

        c_exponential_filter_p = POINTER(ExponentialFilter)

        # Make sure the input array is an array of doubles
        xsd = xs.astype(np.float64, order='C', copy=False)

        extra_args = [cast(c_filters, c_exponential_filter_p)]

        return self._do_simulate(state, n_samples, self.c_simulate_filtered,
                                 xsd.ctypes.data_as(c_double_p), extra_args)

    def simulate_poisson_matrix_source(self, sources, n_samples, state=None):
        """
        Runs the Simulation with the given input xs filtered with the
        exponential low-pass filters defined 
        """

        # Generate the input state
        stated = self._mk_state(state)

        # Make sure the sources array is valid and copy the data over to a
        # C array
        assert (len(sources) == self.n_inputs)
        c_sources = (PoissonMatrixSource * self.n_inputs)()
        for i in range(self.n_inputs):
            PoissonMatrixSource.populate(c_sources[i], sources[i])

        c_poisson_matrix_source_p = POINTER(PoissonMatrixSource)

        return self._do_simulate(state, n_samples,
                                 self.c_simulate_poisson_matrix_source,
                                 c_poisson_matrix_source_p(c_sources))

    @property
    def n_inputs(self):
        return self.assembled_neuron.n_inputs

    @property
    def n_compartments(self):
        return self.assembled_neuron.n_compartments

