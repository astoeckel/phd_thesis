#!/usr/bin/env python3

#   This file is part of NEF Synaptic Computation
#   (c) Andreas St√∂ckel 2017, 2018
#
#   NEF Synaptic Computation is free software: you can redistribute it and/or
#   modify it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   NEF Synaptic Computation is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License along with
#   NEF Synaptic Computation.  If not, see <http://www.gnu.org/licenses/>.

import numbers

def generate_simulator_cpp_code(
        f,
        assm,
        dt=1e-4,
        ss=1,
        record_out=True,
        record_isom=False,
        record_voltages=False,
        record_spike_times=False,
        record_in_refrac=False):

    def _fmt(x):
        res = "{:g}".format(x)
        if (not "." in res):
            s = res.split('e')
            s[0] += '.0'  # Ensure number is C++ double, just '.' would work, but is ugly
            return 'e'.join(s)
        return res

    # Code below compares the result of _fmt to the string "0.0"
    assert _fmt(0) == "0.0" and _fmt(0.0) == "0.0"

    def _fmt_bool(b):
        return "true" if b else "false"

    def _generate_b_vec_entry(i, B, Bconst):
        res = _fmt(Bconst[i])
        if res == "0.0":
            res = ""
        for k in range(B.shape[1]):
            if B[i, k] != 0.0:
                if len(res) > 0:
                    res += " + "
                res += "({} * x[{}])".format(_fmt(B[i, k]), k)
        if res == "":
            return "0.0"
        return res

    def _generate_A_mat_entry(i, j, A, Aconst, C):
        # Lookup off-diagonal entries in the C matrix
        if i != j:
            return _fmt(C[i, j])

        # Assemble diagonal entries according to the Aconst and A matrix
        return _generate_b_vec_entry(i, A, Aconst)

    def _generate_compute_b_code(f, B, Bconst):
        """
        Function used internally to generate the code that computes the B-matrix of
        the linear dynamical system given a certain input vector.
        """
        # Iterate over the rows in b and write the code which computes the
        # corresponding value
        for i in range(B.shape[0]):
            f.write("        gsl_vector_set(tar, {}, ".format(i))
            f.write(_generate_b_vec_entry(i, B, Bconst))
            f.write(");\n")

    # Fetch some constants
    soma = assm._compartments[0]
    n_inputs = len(assm._inputs)
    n_comp = len(assm._compartments)

    """
    Generates the C++ code representing a specific neuron simulator and stores
    it in the given file descriptor.

    Parameters
    ==========

    See `AssembledNeuron.make_simulator()` for a complete list of parameters.

    f: file to which the C++ code should be written.
    assm: AssembledNeuron instance.
    """

    f.write(
        """// This code was automatically generated by multi_compartment_lif_cpp.py

#include "multi_compartment_lif.hpp"

namespace { // Do not export the following symbols
struct Parameters {
    static constexpr double Cm = """ + _fmt(soma.Cm) + """;
    static constexpr double tau_ref = """ + _fmt(soma.tau_ref) + """;
    static constexpr double tau_spike = """ + _fmt(soma.tau_spike) + """;
    static constexpr double v_th = """ + _fmt(soma.v_th) + """;
    static constexpr double v_reset = """ + _fmt(soma.v_reset) + """;
    static constexpr double v_spike = """ + _fmt(soma.v_spike) + """;
    static constexpr size_t n_comp = """ + str(n_comp) + """;
    static constexpr size_t n_inputs = """ + str(n_inputs) + """;
    static constexpr double dt = """ + _fmt(dt) + """;
    static constexpr size_t ss = """ + str(ss) + """;

    static constexpr bool record_out = """ + _fmt_bool(record_out) + """;
    static constexpr bool record_isom = """ + _fmt_bool(record_isom) + """;
    static constexpr bool record_voltages = """ + _fmt_bool(record_voltages) + """;
    static constexpr bool record_spike_times = """ + _fmt_bool(record_spike_times) + """;
    static constexpr bool record_in_refrac = """ + _fmt_bool(record_in_refrac) + """;

    using MatA = Matrix<double, n_comp, n_comp>;
    using VecASom = Matrix<double, 1, n_comp>;
    using VecB = Matrix<double, n_comp, 1>;
    using VecX = Matrix<double, n_inputs, 1>;
    using VecV = Matrix<double, n_comp, 1>;

    static MatA calc_A(const VecX &x) {
        (void)x; // x may be unused, suppress warnings
        return (MatA() <<\n""")
    for i in range(n_comp):
        for j in range(n_comp):
            f.write("            {}".format(_generate_A_mat_entry(
                i, j, assm._A, assm._Aconst, assm._C)))
            if i != n_comp - 1 or j != n_comp - 1:
                f.write(",")
            f.write("\n")
    f.write("""        ).finished();
    }

    static VecB calc_b(const VecX &x) {
        (void)x; // x may be unused, suppress warnings
        return (VecB() <<\n""")
    for i in range(n_comp):
        f.write("            {}".format(_generate_b_vec_entry(
            i, assm._B, assm._Bconst)))
        if i != n_comp - 1:
            f.write(",")
        f.write("\n")
    f.write("""        ).finished();
    }

    static VecASom calc_Asom(const VecX &x) {
        (void)x; // x may be unused, suppress warnings
        return (VecASom() <<\n""")
    for i in range(n_comp):
        f.write("            {}".format(_generate_A_mat_entry(
            0, i, assm._Asom, assm._Asom_const, assm._C)))
        if i != n_comp - 1:
            f.write(",")
        f.write("\n")
    f.write("""        ).finished();
    }

    static double calc_bsom(const VecX &x) {
        (void)x; // x may be unused, suppress warnings
        return """ + _generate_b_vec_entry(0, assm._Bsom, assm._Bsom_const) + """;
    }
};
}

extern "C" { // Exported C API
void simulate(
    double *state,
    const double *xs, uint32_t n, uint32_t *spike_count,
    double *res_out, double *res_isom, double *res_v, double *res_times,
    bool *res_in_refrac) {
    Simulator<Parameters>::run_from_memory(
        state, xs, n, spike_count,
        res_out, res_isom, res_v, res_times, res_in_refrac);
}

void simulate_poisson(
    double *state,
    const PoissonSource *sources, uint32_t n, uint32_t *spike_count,
    double *res_out, double *res_isom, double *res_v, double *res_times,
    bool *res_in_refrac) {
    Simulator<Parameters>::run_with_poisson_sources(
        state, sources, n, spike_count,
        res_out, res_isom, res_v, res_times, res_in_refrac);
}

void simulate_filtered(
    double *state,
    const double *xs, uint32_t n, uint32_t *spike_count,
    double *res_out, double *res_isom, double *res_v, double *res_times,
    bool *res_in_refrac, ExponentialFilter *filters) {
    Simulator<Parameters>::run_with_exponential_filter(
        state, xs, filters, n, spike_count,
        res_out, res_isom, res_v, res_times, res_in_refrac);
}

void simulate_noise_profile(
    double *state, const ExponentialFilter *filters, uint32_t n,
    uint32_t *spike_count, double *res_out, double *res_isom, double *res_v,
    double *res_times, bool *res_in_refrac, 
    const SampledRandomDistribution *p_weights,
    const SampledRandomDistribution *p_isi) {
    Simulator<Parameters>::run_with_noise_profile(
        state, filters, p_weights, p_isi, n, spike_count, res_out, res_isom,
        res_v, res_times, res_in_refrac
    );
}

void simulate_poisson_matrix_source(
    double *state, const PoissonMatrixSource *sources, uint32_t n,
    uint32_t *spike_count, double *res_out, double *res_isom, double *res_v,
    double *res_times, bool *res_in_refrac) {
    Simulator<Parameters>::run_with_matrix_poisson_source(
        state, sources, n, spike_count, res_out, res_isom,
        res_v, res_times, res_in_refrac
    );
}
};
""")


def compile_cpp_library(code, tar):
    import os
    import subprocess
    import posix_ipc

    # Create a semaphore for the given target file. Only one process should try
    # to compile code at a time
    with posix_ipc.Semaphore(os.path.basename(tar), posix_ipc.O_CREAT, initial_value=1) as lock:
        # Someone else compiled the code for us, return!
        if os.path.exists(tar):
            return

        # Fetch the module directory which is used as include directory
        curdir = os.path.dirname(os.path.abspath(__file__))

        debug = False

        # Compile the code
        args = list(filter(lambda x: bool(x), [
            'g++',
            '-std=c++11',
            '-march=native', # Compile for this particular computer
            '-g' if debug else '-DNDEBUG', # Toggle debug code
            '-O0' if debug else '-O3', # Toggle optimisation
            '-Wall',
            '-Wextra',
            '-fno-exceptions',  # This code does not use exceptions
            '-fno-rtti',  # We don't need no runtime-type information
            '-ffast-math',  # Be sloppy, we don't have non-finite math
            '-I' + os.path.expanduser('~/.local/include/eigen3'),
            '-I/usr/include/eigen3',
            '-I' + curdir,
            '-x',  # Specify the language since we're compiling from stdin
            'c++',
            '-fPIC',
            '-shared',
            None if debug else '-s',
            '-Wl,--as-needed,-soname,' + tar,
            '-lm',
            '-o',
            tar
        ]))

        # Write the source code to a temporary file when debugging
        if debug:
            src = tar + '.cpp'
            with open(src, 'wb') as f:
                f.write(code)
            args.append(src)
        else:
            args.append('-')

        # Call the compiler
        process = subprocess.Popen(
            args,
            stdin=None if debug else subprocess.PIPE,
            stderr=subprocess.PIPE)
        _, stderr = process.communicate(None if debug else code)
        stderr = str(stderr, 'utf-8')
        if process.returncode != 0:
            raise Exception("Error while compiling the C++ code:\n" + stderr)

_tmp_dir = None  # Directory compiled libraries are stored in
_compiled_library_map = {} # Map storing the Simulator objects

def _create_tmp_dir():
    import os
    import tempfile

    global _tmp_dir, _compiled_library_map

    # Create a user-accessible temporary directory
    if _tmp_dir is None or not os.path.exists(_tmp_dir):
        _compiled_library_map = {}
        _tmp_dir = os.path.expanduser('~/.cache/multi_compartment_lif/')
        os.makedirs(_tmp_dir, exist_ok=True, mode=0O755)

    return _tmp_dir

def _file_hash(filename, hasher):
    """
    Feeds the content of the file with the specified file into the hasher.
    """

    with open(filename, 'rb') as f:
        while True:
            data = f.read(65536)
            if not data:
                break
            hasher.update(data)

def compile_simulator_cpp(
        assm,
        dt=1e-4,
        ss=1,
        record_out=True,
        record_isom=False,
        record_voltages=False,
        record_spike_times=False,
        record_in_refrac=False):
    """
    Generates and compiles the C++ simulator library. Returns a callable that
    can be used to  To compiled dynamic library will be stored in a temporary
    directory accessible only to the user running this Python process.
    """
    import io
    import hashlib
    import numpy as np
    import os
    import sys

    # Generate the C++ code
    f = io.StringIO()
    generate_simulator_cpp_code(f, assm, dt, ss,
                                record_out,
                                record_isom,
                                record_voltages,
                                record_spike_times,
                                record_in_refrac)

    # Compute the hash, generate the lookup table key -- if this neuron model
    # has already been compiled, return the corresponding compiled code
    header_file = os.path.join(os.path.dirname(os.path.abspath(__file__)), "multi_compartment_lif.hpp")
    code = f.getvalue().encode('utf-8')
    hasher = hashlib.sha1()
    _file_hash(header_file, hasher)
    _file_hash(__file__, hasher)
    hasher.update(str(os.getuid()).encode('utf-8')) # Different hashes per target
    hasher.update(code)
    sha_hash = hasher.hexdigest()

    key = "multi_comp_lif_" + sha_hash[:8]
    if key in _compiled_library_map:
        return _compiled_library_map[key]

    # Compile the C++ code to a library
    libpath = os.path.join(_create_tmp_dir(), key + '.so')
    compile_cpp_library(code, libpath)

    # Load the C library
    from ctypes import cdll, POINTER, Structure, cast, \
        c_double, c_size_t, c_uint32, c_uint8, c_void_p
    lib = cdll.LoadLibrary(libpath)
    c_simulate = lib.simulate
    c_simulate_poisson = lib.simulate_poisson
    c_simulate_filtered = lib.simulate_filtered
    c_simulate_noise_profile = lib.simulate_noise_profile
    c_simulate_poisson_matrix_source = lib.simulate_poisson_matrix_source

    # C pointer types
    c_double_p = POINTER(c_double)
    c_uint32_p = POINTER(c_uint32)
    c_uint8_p = POINTER(c_uint8)

    # Fetch some variables used in the simulation
    n_inputs = len(assm._inputs)
    n_comp = len(assm._compartments)
    soma = assm._compartments[0]

    TRAFO_NONE = 0
    TRAFO_EXP10 = 1
    TRAFO_EXP10_INV = 2

    class Simulator:

        class PoissonSource(Structure):
            _fields_ = [
                ("seed", c_uint32),
                ("rate", c_double),
                ("gain_min", c_double),
                ("gain_max", c_double),
                ("tau", c_double),
                ("offs", c_double)
            ]

        class ExponentialFilter(Structure):
            _fields_ = [
                ("tau", c_double),
                ("offs", c_double),
                ("gain", c_double)
            ]

            @staticmethod
            def populate(struct, filter_):
                if isinstance(filter_, numbers.Number):
                    struct.tau = filter_
                    struct.offs = 0.0
                    struct.gain = 1.0
                else:
                    struct.tau = filter_.tau
                    struct.offs = filter_.offs
                    struct.gain = filter_.gain

        class SampledRandomDistribution(Structure):
            _fields_ = [
                ("seed", c_uint32),
                ("n", c_uint32),
                ("tbl", c_double_p),
                ("trafo", c_uint32),
            ]

            @staticmethod
            def populate(struct, distr):
                struct.seed = distr.seed
                struct.n = distr.n
                struct.tbl = distr.tbl
                struct.trafo = distr.trafo

                if hasattr(distr, 'qs_'):
                    setattr(struct, 'qs_', distr.qs_)

            @staticmethod
            def create(qs, trafo=TRAFO_NONE, seed=None):
                # Make sure qs has the correct format
                qs = np.array(qs, dtype=np.float64, order='C')

                struct = Simulator.SampledRandomDistribution()
                struct.seed = np.random.randint(4294967295) if seed is None else seed
                struct.n = qs.size
                struct.tbl = qs.ctypes.data_as(c_double_p)
                struct.trafo = trafo

                # Make sure qs is not deleted
                setattr(struct, 'qs_', qs)

                return struct

        class PoissonMatrixSource(Structure):
            _fields_ = [
                ("seed", c_uint32),
                ("tau", c_double),
                ("offs", c_double),
                ("gain", c_double),
                ("n", c_uint32),
                ("rates", c_double_p),
                ("weights", c_double_p)
            ]

            @staticmethod
            def populate(struct, source):
                struct.seed = source.seed
                struct.tau = source.tau
                struct.offs = source.offs
                struct.gain = source.gain
                struct.n = source.n
                struct.rates = source.rates
                struct.weights = source.weights

                # Make sure rates and weights are not deleted
                if hasattr(source, 'rates_'):
                    setattr(struct, 'rates_', source.rates_)
                if hasattr(source, 'weights_'):
                    setattr(struct, 'weights_', source.weights_)

            @staticmethod
            def create(tau, rates, weights, seed=None, offs=0.0, gain=1.0):
                # Make sure rates and weights have the correct format
                rates = np.array(rates, dtype=np.float64, order='C')
                weights = np.array(weights, dtype=np.float64, order='C')

                assert rates.size == weights.size
                struct = Simulator.PoissonMatrixSource()
                struct.seed = np.random.randint(4294967295) if seed is None else seed
                struct.tau = tau
                struct.offs = offs
                struct.gain = gain
                struct.n = rates.size
                struct.rates = rates.ctypes.data_as(c_double_p)
                struct.weights = weights.ctypes.data_as(c_double_p)

                # Make sure rates and weights are not deleted
                setattr(struct, 'rates_', rates)
                setattr(struct, 'weights_', weights)

                return struct

        @staticmethod
        def _mk_state(state):
            if state is None:
                state = np.ones(n_comp + 1, dtype=np.float64) * soma.v_reset
                state[-1] = 0.0  # Refractory potential
            else:
                assert state.size == n_comp + 1
            return state.astype(np.float64, order='C', copy=False)


        @staticmethod
        def _do_simulate(state, n_samples, c_fun, c_xs_p, extra_args=[]):
            # Generate the input state
            stated = Simulator._mk_state(state);

            # An upper bound on the number of spikes the neuron can produce
            tau_ref = assm.soma().tau_ref
            if tau_ref > 0:
                max_n_spikes = np.ceil(1.0 / assm.soma().tau_ref) * np.ceil(n_samples * dt * ss) + 1
            else:
                max_n_spikes = n_samples

            # Generate the output arrays
            res_out = np.zeros(n_samples, np.float64) if record_out else None
            res_isom = np.empty(n_samples, np.float64) if record_isom else None
            res_v = np.empty(
                (n_samples, n_comp), np.float64) if record_voltages else None
            res_times = np.empty(
                int(max_n_spikes),
                np.float64) if record_spike_times else None
            res_in_refrac = np.zeros(
                n_samples, np.bool) if record_in_refrac else None

            # Memory storing the number of output spikes
            n_spikes = np.zeros(1, np.uint32)

            # Run the simulation
            c_fun(
                stated.ctypes.data_as(c_double_p),
                c_xs_p,
                c_uint32(n_samples),
                n_spikes.ctypes.data_as(c_uint32_p),
                res_out.ctypes.data_as(c_double_p) if record_out else c_void_p(0),
                res_isom.ctypes.data_as(
                    c_double_p) if record_isom else c_void_p(0),
                res_v.ctypes.data_as(
                    c_double_p) if record_voltages else c_void_p(0),
                res_times.ctypes.data_as(
                    c_double_p) if record_spike_times else c_void_p(0),
                res_in_refrac.ctypes.data_as(c_uint8_p) if record_in_refrac else c_void_p(0),
                *extra_args)

            # Convert the spike times array to a list
            if record_spike_times:
                res_times = res_times[:n_spikes[0]]

            return assm.SimulationResult(
                stated, res_out, res_isom,
                res_v, res_times, res_in_refrac)

        @staticmethod
        def simulate_poisson(sources, n_samples, state=None):
            """
            Runs the Simulation for a set of poisson sources as input.
            """
            # Generate the input state
            stated = Simulator._mk_state(state)

            # Make sure the number of input samples is valid
            n_samples = int(n_samples)
            assert(n_samples >= 0)

            # Make sure the sources array is valid and copy the data over to a
            # C array
            assert(len(sources) == n_inputs)
            c_sources = (Simulator.PoissonSource * n_inputs)()
            for i in range(n_inputs):
                c_sources[i].seed = sources[i].seed
                c_sources[i].rate = sources[i].rate
                c_sources[i].gain_min = sources[i].gain_min
                c_sources[i].gain_max = sources[i].gain_max
                c_sources[i].tau = sources[i].tau
                c_sources[i].offs = sources[i].offs

            c_poisson_source_p = POINTER(Simulator.PoissonSource)

            return Simulator._do_simulate(state, n_samples, c_simulate_poisson, cast(c_sources, c_poisson_source_p))

        @staticmethod
        def simulate_noise_profile(qs_weights, qs_isi, filters, n_samples, state=None):
            """
            Runs the simulation where the input spikes and weightings are
            sampled from two pre-defined random distribution.
            """

            # Make sure the number of noise distributions/filters corresponds
            # to the number of input channels
            assert(len(qs_weights) == len(qs_isi) == len(filters) == n_inputs)

            c_qs_weights = (Simulator.SampledRandomDistribution * n_inputs)()
            c_qs_isi = (Simulator.SampledRandomDistribution * n_inputs)()
            c_filters = (Simulator.ExponentialFilter * n_inputs)()
            for i in range(n_inputs):
                assert(isinstance(qs_weights[i], Simulator.SampledRandomDistribution))
                assert(isinstance(qs_isi[i], Simulator.SampledRandomDistribution))

                Simulator.SampledRandomDistribution.populate(c_qs_weights[i], qs_weights[i])
                Simulator.SampledRandomDistribution.populate(c_qs_isi[i], qs_isi[i])
                Simulator.ExponentialFilter.populate(c_filters[i], filters[i])

            c_exponential_filter_p = POINTER(Simulator.ExponentialFilter)
            c_sampled_random_distribution_p = POINTER(Simulator.SampledRandomDistribution)

            return Simulator._do_simulate(state, n_samples, c_simulate_noise_profile,
                    cast(c_filters, c_exponential_filter_p), [
                    cast(c_qs_weights, c_sampled_random_distribution_p),
                    cast(c_qs_isi, c_sampled_random_distribution_p),
                ])


        @staticmethod
        def simulate(xs, state=None):
            """
            Runs the Simulation with the given input xs. xs is a 2D matrix
            containing the input for each point in time.
            """

            # Make sure the given xs vector has the correct shape
            xs = assm._canonicalise_input_array(xs).T

            # Fetch some values used throughout the function
            n_samples = xs.shape[0]

            # Make sure the input array is an array of doubles
            xsd = xs.astype(np.float64, order='C', copy=False)

            return Simulator._do_simulate(state, n_samples, c_simulate, xsd.ctypes.data_as(c_double_p))

        @staticmethod
        def simulate_filtered(xs, filters, state=None):
            """
            Runs the Simulation with the given input xs filtered with the
            exponential low-pass filters defined 
            """

            # Generate the input state
            stated = Simulator._mk_state(state)

            # Make sure the given xs vector has the correct shape
            xs = assm._canonicalise_input_array(xs).T

            # Make sure the number of input samples is valid
            n_samples = xs.shape[0]

            # Make sure the sources array is valid and copy the data over to a
            # C array
            assert(len(filters) == n_inputs)
            c_filters = (Simulator.ExponentialFilter * n_inputs)()
            for i in range(n_inputs):
                Simulator.ExponentialFilter.populate(c_filters[i], filters[i])

            c_exponential_filter_p = POINTER(Simulator.ExponentialFilter)

            # Make sure the input array is an array of doubles
            xsd = xs.astype(np.float64, order='C', copy=False)

            extra_args = [
                cast(c_filters, c_exponential_filter_p)
            ]

            return Simulator._do_simulate(state, n_samples, c_simulate_filtered, xsd.ctypes.data_as(c_double_p), extra_args)

        @staticmethod
        def simulate_poisson_matrix_source(sources, n_samples, state=None):
            """
            Runs the Simulation with the given input xs filtered with the
            exponential low-pass filters defined 
            """

            # Generate the input state
            stated = Simulator._mk_state(state)

            # Make sure the sources array is valid and copy the data over to a
            # C array
            assert(len(sources) == n_inputs)
            c_sources = (Simulator.PoissonMatrixSource * n_inputs)()
            for i in range(n_inputs):
                Simulator.PoissonMatrixSource.populate(c_sources[i], sources[i])

            c_poisson_matrix_source_p = POINTER(Simulator.PoissonMatrixSource)

            return Simulator._do_simulate(state, n_samples, c_simulate_poisson_matrix_source, c_poisson_matrix_source_p(c_sources))

    # Make sure all the arguments are accessible as class members
    setattr(Simulator, 'dt', dt)
    setattr(Simulator, 'ss', ss)
    setattr(Simulator, 'record_out', record_out)
    setattr(Simulator, 'record_isom', record_isom)
    setattr(Simulator, 'record_voltages', record_voltages)
    setattr(Simulator, 'record_in_refrac', record_in_refrac)
    setattr(Simulator, 'record_spike_times', record_spike_times)
    setattr(Simulator, 'TRAFO_NONE', TRAFO_NONE)
    setattr(Simulator, 'TRAFO_EXP10', TRAFO_EXP10)
    setattr(Simulator, 'TRAFO_EXP10_INV', TRAFO_EXP10_INV)

    # Register the above function for the specific neuron type and return it
    _compiled_library_map[key] = Simulator

    return Simulator

_supports_cpp = True
def supports_cpp():
    global _supports_cpp, _compiled_library_map
    if _supports_cpp is None:
        import os

        # Create a user-accessible temporary directory
        tar = os.path.join(_create_tmp_dir(), 'test.so')

        # Try to compile a minimal library which just includes eigen
        try:
            compile_cpp_library(
                b"\"multi_compartment_lif.hpp\"\n#include <Eigen/Dense>\n#include <Eigen/Eigenvalues>", tar)
            _supports_cpp = True
        except:
            _supports_cpp = False

        # Remove the target file
        if os.path.exists(tar):
            os.remove(tar)

    return _supports_cpp

if __name__ == "__main__":
    import sys
    from multi_compartment_lif import Neuron, Compartment, CurChan, CondChan

    # Create a simple test neuron
    CondNLif = (Neuron()
                .add_compartment(Compartment(soma=True)
                                 .add_channel(CondChan(Erev=-65e-3, g=50e-9, name="leak"))
                                 .add_channel(CurChan(name="exc")))
                .add_compartment(Compartment(name="proximal_1")
                                 .add_channel(CondChan(Erev=20e-3, name="exc"))
                                 .add_channel(CondChan(Erev=-75e-3, name="inh"))
                                 .add_channel(CondChan(Erev=-65e-3, g=50e-9, name="leak")))
                .add_compartment(Compartment(name="distal")
                                 .add_channel(CondChan(Erev=20e-3, name="exc"))
                                 .add_channel(CondChan(Erev=-75e-3, name="inh"))
                                 .add_channel(CondChan(Erev=-65e-3, g=50e-9, name="leak")))
                .add_compartment(Compartment(name="proximal_2")
                                 .add_channel(CondChan(Erev=20e-3, name="exc"))
                                 .add_channel(CondChan(Erev=-75e-3, name="inh"))
                                 .add_channel(CondChan(Erev=-65e-3, g=50e-9, name="leak")))
                .connect("soma", "proximal_1", 10e-9)
                .connect("proximal_1", "distal", 10e-9)
                .connect("soma", "proximal_2", 100e-9)
                .assemble())

    LIF = (Neuron() 
        .add_compartment(Compartment(soma=True)
            .add_channel(CurChan(name="j"))
            .add_channel(CurChan(name="j2"))
            .add_channel(CondChan(Erev=-65e-3, g=1e-9, name="leak")))
        .assemble())

#    # Generate the corresponding simulator object
#    simulator = compile_simulator_cpp(LIF, record_spike_times=True, record_isom=True, record_voltages=True)

#    # Generate some input data
#    import numpy as np
#    n_samples = 4096
#    xs = np.array((
#        np.ones(n_samples) * 1e-9,
#        np.ones(n_samples) * 2e-9
#    ))
#    res1 = simulator.simulate(xs)

#    # Same for a PoissonSource
#    xs_poisson = [
#        simulator.PoissonSource(
#            41829,
#            0,
#            0e-9,
#            0e-9,
#            5e-3,
#            1e-9
#        ),
#        simulator.PoissonSource(
#            41829,
#            0,
#            0e-9,
#            0e-9,
#            5e-3,
#            2e-9
#        ),
#    ]
#    res2 = simulator.simulate_poisson(xs_poisson, n_samples)

#    print(res1.times)
#    print(res2.times)

    import matplotlib.pyplot as plt

#    fig, ax = plt.subplots()
#    ax.plot(res1.v);
#    ax.plot(res2.v);

#    # Test simulate_filtered
#    xs = np.array(([0] * 9 + [1] + [0] * 90) * 10) / simulator.dt * 0.1e-9
#    ts = np.arange(0, len(xs)) * simulator.dt

#    import nengo
#    tau_filt = 10e-3
#    xs_filt = nengo.Lowpass(tau_filt).filt(xs, dt=simulator.dt)

#    res1 = simulator.simulate(np.array((xs_filt, xs_filt)))
#    res2 = simulator.simulate_filtered(np.array((xs, xs)), (tau_filt, tau_filt))

#    fig, ax = plt.subplots()
#    plt.plot(ts, res1.out)
#    plt.plot(ts, res2.out)

#    # Test running with a ultra-short dt and only recording the spike times
#    dt = 1e-9
#    simulator = compile_simulator_cpp(LIF, dt=dt, ss=100000,
#            record_out=True, record_isom=False, record_voltages=False,
#            record_spike_times=True, record_in_refrac=False)

#    res1 = simulator.simulate(np.array((xs_filt, xs_filt)))
#    res2 = simulator.simulate_filtered(np.array((xs, xs)), (tau_filt, tau_filt))

#    fig, ax = plt.subplots()
#    plt.plot(ts, res1.out)
#    for t in res1.times:
#        print(t)
#        plt.plot([t, t], [-0.1, 0.1], 'r-')
#    plt.plot(ts, res2.out)
#    for t in res2.times:
#        print(t, "*")
#        plt.plot([t, t], [-0.1, 0.1], 'b-')


    # Test with a noise profile
    import numpy as np
#    import h5py

#    T = 100.0
#    dt = 1e-4
#    ts = np.arange(0, T, dt)
#    simulator = compile_simulator_cpp(LIF, dt=dt)

#    res = LIF._simulate_noisy(simulator, len(ts), [2e-9, -1e-9], '/home/astoecke/Uni/PhD/paper/2018_11_nonlinear_synaptic_interaction/code/weights_2019_02_22_17_43_26_profiles.h5', (5e-3, 10e-3), 1000)

#    plt.plot(ts, res.out)

    T = 10.0
    dt = 1e-4
    ts = np.arange(0, T, dt)
    simulator = compile_simulator_cpp(LIF, dt=dt, record_spike_times=True, record_isom=False, record_voltages=True, record_out=False, record_in_refrac=False)

#    rates_1 = np.array((50, 500, 5000), dtype=np.float64)
#    weights_1 = np.array((1e-9, 0.0, 0.0))

#    rates_2 = np.array((100, 1000), dtype=np.float64)
#    weights_2 = np.array((-1.0e-9, 0.0), dtype=np.float64)

#    sources = [
#        simulator.PoissonMatrixSource.create(50e-3, rates_1, weights_1),
#        simulator.PoissonMatrixSource.create(100e-3, rates_2, weights_2),
#    ]
#    res = simulator.simulate_poisson_matrix_source(sources, len(ts))
#    print(res.times)

    NN = 100
    rates = np.random.uniform(50, 100, NN)
    weights = np.random.uniform(0, 10e-12, (2, NN))
    weights[1] *= -0.5

    res = LIF._simulate_noisy(simulator, len(ts), np.array((1e-9, 0.5e-9)), weights, (5e-3, 10e-3), rates)

    print(res.times)

#    fig, ax = plt.subplots()
#    ax.plot(ts, res.v)

#    plt.show()
